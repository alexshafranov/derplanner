//
// Copyright (c) 2015 Alexander Shafranov shafranov@gmail.com
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//

#include <algorithm> // std::sort

#include "derplanner/compiler/io.h"
#include "derplanner/compiler/array.h"
#include "derplanner/compiler/id_table.h"
#include "derplanner/compiler/string_buffer.h"
#include "derplanner/compiler/signature_table.h"
#include "derplanner/compiler/function_table.h"
#include "derplanner/compiler/ast.h"
#include "derplanner/compiler/lexer.h"
#include "derplanner/compiler/codegen.h"

#include "derplanner/runtime/database.h" // murmur2_32

using namespace plnnrc;

void plnnrc::init(Codegen* self, ast::Root* tree, Memory_Stack* scratch)
{
    memset(self, 0, sizeof(Codegen));
    self->tree = tree;
    self->scratch = scratch;
}

void plnnrc::generate_header(Codegen* self, const char* header_guard, Writer* output)
{
    Formatter fmtr;
    init(fmtr, "  ", "\n", output);

    ast::Root* tree = self->tree;
    ast::Domain* domain = tree->domain;

    const Token_Value domain_name = domain->name;
    writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
    writeln(fmtr, "#ifndef %s", header_guard);
    writeln(fmtr, "#define %s", header_guard);
    writeln(fmtr, "#pragma once");
    newline(fmtr);
    writeln(fmtr, "#include \"derplanner/runtime/types.h\"");
    newline(fmtr);
    writeln(fmtr, "#ifndef PLNNR_DOMAIN_API");
    writeln(fmtr, "#define PLNNR_DOMAIN_API");
    writeln(fmtr, "#endif");
    newline(fmtr);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API void %n_init_domain_info();", domain_name);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API const plnnr::Domain_Info* %n_get_domain_info();", domain_name);
    newline(fmtr);
    writeln(fmtr, "#endif");
    flush(fmtr);
}

static void generate_precondition(Codegen* self, uint32_t case_idx, Formatter& fmtr);
static void generate_comparator(Codegen* self, ast::Expr* key_expr, Token_Type key_type, bool has_args, uint32_t case_index, uint32_t struct_index, uint32_t output_index, Formatter& fmtr);
static void generate_empty_expansion(Codegen* self, ast::Task* task, Formatter& fmtr);
static void generate_expansion(Codegen* self, ast::Case* case_, uint32_t case_idx, Formatter& fmtr);
static void generate_conjunct(Codegen* self, ast::Case* case_, ast::Expr* literal, uint32_t& handle_id, uint32_t& yield_id, bool store_binds, uint32_t case_index, uint32_t output_index, Formatter& fmtr);

static const char* s_runtime_type_tag[] =
{
    #define PLNNR_TYPE(TAG, TYPE) #TAG,
    #include "derplanner/runtime/type_tags.inl"
    #undef PLNNR_TYPE
};

static const char* s_runtime_type_enum[] =
{
    #define PLNNR_TYPE(TAG, TYPE) "Type_" #TAG,
    #include "derplanner/runtime/type_tags.inl"
    #undef PLNNR_TYPE
};

static const char* s_runtime_type_name[] =
{
    #define PLNNR_TYPE(TAG, TYPE) #TYPE,
    #include "derplanner/runtime/type_tags.inl"
    #undef PLNNR_TYPE
};

static const char* get_runtime_type_tag(Token_Type token_type)
{
    plnnrc_assert(token_type >= (Token_Type)Token_Group_Type_First);
    return s_runtime_type_tag[token_type - Token_Group_Type_First];
}

static const char* get_runtime_type_enum(Token_Type token_type)
{
    plnnrc_assert(token_type >= (Token_Type)Token_Group_Type_First);
    return s_runtime_type_enum[token_type - Token_Group_Type_First];
}

static const char* get_runtime_type_name(Token_Type token_type)
{
    plnnrc_assert(token_type >= (Token_Type)Token_Group_Type_First);
    return s_runtime_type_name[token_type - Token_Group_Type_First];
}

static void build_signatures(Codegen* self)
{
    ast::Root* tree = self->tree;
    ast::Primitive* prim = tree->primitive;
    ast::Domain* domain = tree->domain;

    // primitive task signatures.
    for (uint32_t task_idx = 0; task_idx < size(prim->tasks); ++task_idx)
    {
        ast::Fact* task = prim->tasks[task_idx];

        begin_signature(self->task_and_binding_sigs);
        for (uint32_t param_idx = 0; param_idx < size(task->params); ++param_idx)
        {
            add_param(self->task_and_binding_sigs, task->params[param_idx]->data_type);
        }
        end_signature(self->task_and_binding_sigs);
    }

    // compound task signatures.
    for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
    {
        ast::Task* task = domain->tasks[task_idx];

        begin_signature(self->task_and_binding_sigs);
        for (uint32_t param_idx = 0; param_idx < size(task->params); ++param_idx)
        {
            add_param(self->task_and_binding_sigs, task->params[param_idx]->data_type);
        }
        end_signature(self->task_and_binding_sigs);
    }

    // precondition output.
    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        ast::Case* case_ = tree->cases[case_idx];

        begin_signature(self->task_and_binding_sigs);
        for (uint32_t var_idx = 0; var_idx < size(case_->precond_vars); ++var_idx)
        {
            ast::Var* var = case_->precond_vars[var_idx];
            // skip if not the first occurrence.
            if (var->definition != 0) { continue; }
            // save variable index in output signature.
            var->output_index = add_param(self->task_and_binding_sigs, var->data_type);
        }
        end_signature(self->task_and_binding_sigs);
    }

    // build separate set of signatures for task params and precdondition outputs (i.e. bindings).
    // the signatures will be used to generate structs for task arguments access and
    // precondition outputs access.

    // compound tasks.
    for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
    {
        ast::Task* task = domain->tasks[task_idx];

        begin_signature(self->struct_sigs);
        for (uint32_t param_idx = 0; param_idx < size(task->params); ++param_idx)
        {
            add_param(self->struct_sigs, task->params[param_idx]->data_type);
        }
        end_signature(self->struct_sigs);
    }

    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        ast::Case* case_ = tree->cases[case_idx];
        ast::Task* task = case_->task;

        for (uint32_t param_idx = 0; param_idx < size(task->params); ++param_idx)
        {
            ast::Param* param = task->params[param_idx];
            ast::Var* var = get(case_->precond_var_lookup, param->name);
            if (!var) { continue; }
            var->input_index = param_idx;
        }
    }

    // precondition outputs.
    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        ast::Case* case_ = tree->cases[case_idx];

        begin_signature(self->struct_sigs);
        for (uint32_t var_idx = 0; var_idx < size(case_->precond_vars); ++var_idx)
        {
            ast::Var* var = case_->precond_vars[var_idx];
            // skip if not the first occurrence.
            if (var->definition != 0) { continue; }
            add_param(self->struct_sigs, var->data_type);
        }
        end_signature(self->struct_sigs);
    }

    // propagate indices to all case variables.
    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        ast::Case* case_ = tree->cases[case_idx];
        ast::Task* task = case_->task;

        for (uint32_t var_idx = 0; var_idx < size(case_->precond_vars); ++var_idx)
        {
            ast::Var* var = case_->precond_vars[var_idx];
            ast::Var* first = get(case_->precond_var_lookup, var->name);
            var->input_index = first->input_index;
        }

        for (uint32_t var_idx = 0; var_idx < size(case_->task_list_vars); ++var_idx)
        {
            ast::Var* var = case_->task_list_vars[var_idx];
            ast::Var* first = get(case_->precond_var_lookup, var->name);

            if (first)
            {
                var->input_index = first->input_index;
            }
            else
            {
                ast::Param* param = as_Param(var->definition);
                uint32_t task_param_idx = index_of(task->params, param);
                var->input_index = task_param_idx;
            }
        }

        for (uint32_t attr_idx = 0; attr_idx < size(case_->attrs); ++attr_idx)
        {
            ast::Attribute* attr = case_->attrs[attr_idx];
            for (uint32_t arg_idx = 0; arg_idx < size(attr->args); ++arg_idx)
            {
                ast::Expr* arg = attr->args[arg_idx];
                for (ast::Expr* node = arg; node != 0; node = preorder_next(arg, node))
                {
                    if (ast::Var* var = as_Var(node))
                    {
                        ast::Var* first = get(case_->precond_var_lookup, var->name);

                        if (first)
                        {
                            var->input_index = first->input_index;
                        }
                        else
                        {
                            ast::Param* param = as_Param(var->definition);
                            uint32_t task_param_idx = index_of(task->params, param);
                            var->input_index = task_param_idx;
                        }
                    }
                }
            }
        }
    }
}

static void build_expand_names(String_Buffer& expand_names, ast::Domain* domain)
{
    for (uint32_t task_idx = 0; task_idx < plnnrc::size(domain->tasks); ++task_idx)
    {
        ast::Task* task = domain->tasks[task_idx];
        for (uint32_t case_idx = 0; case_idx < plnnrc::size(task->cases); ++case_idx)
        {
            begin_string(expand_names);
            write(expand_names.buffer, "%n_case_%d", task->name, case_idx);
            end_string(expand_names);
        }
    }
}

static bool all_unique(Array<uint32_t>& hashes)
{
    if (empty(hashes))
    {
        return true;
    }

    std::sort(&hashes[0], &hashes[0] + size(hashes));
    for (uint32_t i = 1; i < size(hashes); ++i)
    {
        uint32_t prev = hashes[i - 1];
        uint32_t curr = hashes[i + 0];
        if (curr == prev)
        {
            return false;
        }
    }

    return true;
}

static bool build_hashes(const Array<Token_Value>& names, Array<uint32_t>& out_hashes, uint32_t& out_seed)
{
    resize(out_hashes, size(names));
    const uint32_t max_seed = 1000;

    for (uint32_t test_seed = 0; test_seed < max_seed; ++test_seed)
    {
        for (uint32_t i = 0; i < size(names); ++i)
        {
            out_hashes[i] = plnnr::murmur2_32(names[i].str, names[i].length, test_seed);
        }

        if (all_unique(out_hashes))
        {
            out_seed = test_seed;

            // rebuild hashes as the order of out_hashes was destroyed by sorting in `all_unique`.
            for (uint32_t i = 0; i < size(names); ++i)
            {
                out_hashes[i] = plnnr::murmur2_32(names[i].str, names[i].length, test_seed);
            }

            return true;
        }
    }

    return false;
}

struct Expr_Writer
{
    Formatter* fmtr;
    ast::Root* tree;

    void visit(const ast::Var* node)
    {
        // the variable is an assignment target.
        if (!node->definition)
        {
            write(*fmtr, "binds->_%d", node->output_index);
            return;
        }

        if (is_Param(node->definition))
        {
            write(*fmtr, "args->_%d", node->input_index);
            return;
        }

        if (is_Var(node->definition))
        {
            write(*fmtr, "binds->_%d", node->output_index);
            return;
        }

        plnnrc_assert(false);
    }

    void visit(const ast::Literal* node)
    {
        if (is_Literal_Fact(node->value_type))
        {
            ast::Fact* fact = get_fact(tree, node->value);
            plnnrc_assert(fact);
            const uint32_t fact_idx = index_of(tree->world->facts, fact);
            write(*fmtr, "db->tables + %d", fact_idx);
        }
        else
        {
            write(*fmtr, "%n", node->value);
        }
    }

    const char* get_op_str(ast::Node_Type node_type)
    {
        switch (node_type)
        {
        case ast::Node_Or: return "||";
        case ast::Node_And: return "&&";
        case ast::Node_Not: return "!";
        case ast::Node_Assign: return "=";
        case ast::Node_Equal: return "==";
        case ast::Node_NotEqual: return "!=";
        case ast::Node_Less: return "<";
        case ast::Node_LessEqual: return "<=";
        case ast::Node_Greater: return ">";
        case ast::Node_GreaterEqual: return ">=";
        case ast::Node_Plus: return "+";
        case ast::Node_Minus: return "-";
        case ast::Node_Mul: return "*";
        case ast::Node_Div: return "/";
        default:
            plnnrc_assert(false);
            return "";
        }
    }

    void visit(const ast::Op* node)
    {
        const char* op = get_op_str(node->type);
        plnnrc_assert(node->child);

        // unary
        if (!node->child->next_sibling)
        {
            plnnrc_assert(is_Plus(node) || is_Minus(node) || is_Not(node));
            write(*fmtr, "%s", op);
            write(*fmtr, "(");
            visit_node<void>(node->child, this);
            write(*fmtr, ")");
        }
        // binary
        else
        {
            write(*fmtr, "(");
            for (ast::Expr* arg = node->child; arg != 0; arg = arg->next_sibling)
            {
                visit_node<void>(arg, this);
                if (arg->next_sibling != 0)
                    write(*fmtr, " %s ", op);
            }
            write(*fmtr, ")");
        }
    }

    void visit(const ast::Func* func)
    {
        const Signature sig = get_params_signature(tree->functions, func->signature_index);
        plnnrc_assert(sig.length == size(func->args));

        write(*fmtr, "plnnr::%n(", func->name);
        for (uint32_t arg_idx = 0; arg_idx < size(func->args); ++arg_idx)
        {
            const ast::Expr* arg = func->args[arg_idx];
            const Token_Type param_type = sig.types[arg_idx];

            write(*fmtr, "%s(", get_runtime_type_name(param_type));
            visit_node<void>(arg, this);
            write(*fmtr, ")");

            if (arg->next_sibling != 0)
                write(*fmtr, ", ");
        }
        write(*fmtr, ")");
    }

    void visit(const ast::Node*) { plnnrc_assert(false); }
};

void plnnrc::generate_source(Codegen* self, const char* domain_header, Writer* output)
{
    Memory_Stack_Scope scratch_scope(self->scratch);

    Formatter fmtr;
    init(fmtr, "  ", "\n", output);

    ast::Root* tree = self->tree;
    ast::World* world = tree->world;
    ast::Primitive* prim = tree->primitive;
    ast::Domain* domain = tree->domain;

    init(self->expand_names, self->scratch, 64, 4096);
    init(self->task_and_binding_sigs, self->scratch, size(prim->tasks) + size(domain->tasks) + size(tree->cases));
    init(self->struct_sigs, self->scratch, size(domain->tasks) + size(tree->cases));

    // includes & pragmas
    {
        writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
        writeln(fmtr, "#include \"derplanner/runtime/domain.h\"");
        writeln(fmtr, "#include \"%s\"", domain_header);
        newline(fmtr);
        writeln(fmtr, "using namespace plnnr;");
        newline(fmtr);
        writeln(fmtr, "#ifdef __GNUC__");
        writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-parameter\"");
        writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-variable\"");
        writeln(fmtr, "#endif");
        newline(fmtr);
        writeln(fmtr, "#ifdef _MSC_VER");
        writeln(fmtr, "#pragma warning(disable: 4100) // unreferenced formal parameter");
        writeln(fmtr, "#pragma warning(disable: 4189) // local variable is initialized but not referenced");
        writeln(fmtr, "#endif");
        newline(fmtr);
    }

    build_expand_names(self->expand_names, domain);

    // expand forward declarations
    {
        for (uint32_t case_idx = 0; case_idx < size(self->expand_names); ++case_idx)
        {
            Token_Value name = get(self->expand_names, case_idx);
            writeln(fmtr, "static bool %n(Planning_State*, Expansion_Frame*, Fact_Database*);", name);
        }

        // tasks with no cases
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            ast::Task* task = domain->tasks[task_idx];
            if (empty(task->cases))
            {
                writeln(fmtr, "static bool %n_case_0(Planning_State*, Expansion_Frame*, Fact_Database*);", task->name);
            }
        }

        newline(fmtr);
    }

    // s_task_expands
    {
        writeln(fmtr, "static Compound_Task_Expand* s_task_expands[] = {");
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            ast::Task* task = domain->tasks[task_idx];
            Indent_Scope s(fmtr);
            writeln(fmtr, "%n_case_0,", task->name);
        }

        if (empty(domain->tasks))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_fact_names
    {
        writeln(fmtr, "static const char* s_fact_names[] = {");
        for (uint32_t fact_idx = 0; fact_idx < size(world->facts); ++fact_idx)
        {
            Indent_Scope s(fmtr);
            ast::Fact* fact = world->facts[fact_idx];
            writeln(fmtr, "\"%n\",", fact->name);
        }

        if (empty(world->facts))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, " };");
        newline(fmtr);
    }

    // s_task_names
    {
        writeln(fmtr, "static const char* s_task_names[] = {");
        // primitive tasks go first.
        for (uint32_t prim_idx = 0; prim_idx < size(prim->tasks); ++prim_idx)
        {
            Indent_Scope s(fmtr);
            ast::Fact* task = prim->tasks[prim_idx];
            writeln(fmtr, "\"%n\",", task->name);
        }
        // compound tasks after.
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            Indent_Scope s(fmtr);
            ast::Task* task = domain->tasks[task_idx];
            writeln(fmtr, "\"%n\",", task->name);
        }

        if (empty(prim->tasks) && empty(domain->tasks))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, " };");
        newline(fmtr);
    }

    // s_fact_types
    {
        writeln(fmtr, "static Fact_Type s_fact_types[] = {");
        for (uint32_t fact_idx = 0; fact_idx < size(world->facts); ++fact_idx)
        {
            ast::Fact* fact = world->facts[fact_idx];
            uint32_t num_params = size(fact->params);
            Indent_Scope s(fmtr);
            write(fmtr, "%i{ %d, {", num_params);
            for (uint32_t param_idx = 0; param_idx < num_params; ++param_idx)
            {
                const char* type_name = get_runtime_type_enum(fact->params[param_idx]->data_type);
                write(fmtr, "%s, ", type_name);
            }
            write(fmtr, "} },");
            newline(fmtr);
        }

        if (empty(world->facts))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "{ 0, { Type_None, } }");
        }

        writeln(fmtr, "};");
        newline(fmtr);
    }

    build_signatures(self);

    // s_layout_types, s_layout_offsets
    if (size(self->task_and_binding_sigs.types) > 0)
    {
        writeln(fmtr, "static Type s_layout_types[] = {");
        for (uint32_t type_idx = 0; type_idx < size(self->task_and_binding_sigs.types); ++type_idx)
        {
            Token_Type type = self->task_and_binding_sigs.types[type_idx];
            Indent_Scope s(fmtr);
            writeln(fmtr, "%s,", get_runtime_type_enum(type));
        }
        writeln(fmtr, "};");
        newline(fmtr);

        writeln(fmtr, "static size_t s_layout_offsets[%d];", size(self->task_and_binding_sigs.types));
        newline(fmtr);
    }

    // s_task_parameters & s_bindings.
    {
        struct Format_Param_Layout
        {
            void operator()(Formatter& fmtr, Signature_Table& signatures, uint32_t sig_idx)
            {
                Signature sig = get_sparse(signatures, sig_idx);

                Indent_Scope s(fmtr);
                if (sig.length > 0)
                {
                    writeln(fmtr, "{ %d, 0, 0, s_layout_types + %d, s_layout_offsets + %d },", sig.length, sig.offset, sig.offset);
                }
                else
                {
                    writeln(fmtr, "{ 0, 0, 0, 0, 0 },");
                }
            }
        };

        const uint32_t num_tasks = size(prim->tasks) + size(domain->tasks);

        writeln(fmtr, "static Param_Layout s_task_parameters[] = {");
        for (uint32_t sig_idx = 0; sig_idx < num_tasks; ++sig_idx)
        {
            Format_Param_Layout()(fmtr, self->task_and_binding_sigs, sig_idx);
        }

        if (!num_tasks)
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "{ 0, 0, 0, 0 }");
        }
        writeln(fmtr, "};");
        newline(fmtr);

        writeln(fmtr, "static Param_Layout s_bindings[] = {");
        for (uint32_t sig_idx = num_tasks; sig_idx < size(self->task_and_binding_sigs.remap); ++sig_idx)
        {
            Format_Param_Layout()(fmtr, self->task_and_binding_sigs, sig_idx);
        }

        if (num_tasks == size(self->task_and_binding_sigs.remap))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "{ 0, 0, 0, 0 }");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_num_cases
    {
        writeln(fmtr, "static uint32_t s_num_cases[] = {");
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            ast::Task* task = domain->tasks[task_idx];
            Indent_Scope s(fmtr);
            writeln(fmtr, "%d, ", size(task->cases));
        }

        if (empty(domain->tasks))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_first_case
    {
        writeln(fmtr, "static uint32_t s_first_case[] = {");
        uint32_t first_case = 0;
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            ast::Task* task = domain->tasks[task_idx];
            Indent_Scope s(fmtr);
            writeln(fmtr, "%d, ", first_case);
            first_case += size(task->cases);
        }

        if (empty(domain->tasks))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_size_hints
    {
        writeln(fmtr, "static uint32_t s_size_hints[] = {");
        for (uint32_t fact_idx = 0; fact_idx < size(world->facts); ++fact_idx)
        {
            Indent_Scope s(fmtr);
            ast::Fact* fact = world->facts[fact_idx];
            ast::Attribute* attr = find_attribute(fact, Attribute_Size);

            if (attr)
            {
                Expr_Writer visitor = { &fmtr, self->tree };
                write(fmtr, "%i");
                const ast::Expr* expr = attr->args[0];
                visit_node<void>(expr, &visitor);
                write(fmtr, ",");
                newline(fmtr);
            }
            else
            {
                writeln(fmtr, "0,");
            }
        }

        if (empty(world->facts))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_num_case_handles
    {
        writeln(fmtr, "static uint32_t s_num_case_handles[] = {");
        for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
        {
            ast::Case* case_ = tree->cases[case_idx];
            Indent_Scope s(fmtr);
            writeln(fmtr, "%d, ", size(case_->precond_facts));
        }

        if (empty(world->facts))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    uint32_t fact_names_hash_seed = 0;
    // s_fact_name_hashes
    {
        Memory_Stack_Scope scratch_scope(self->scratch);

        Array<Token_Value> fact_names;
        init(fact_names, self->scratch, size(world->facts));
        Array<uint32_t> fact_name_hashes;
        init(fact_name_hashes, self->scratch, size(world->facts));

        for (uint32_t fact_idx = 0; fact_idx < size(world->facts); ++fact_idx)
        {
            ast::Fact* fact = world->facts[fact_idx];
            push_back(fact_names, fact->name);
        }

        build_hashes(fact_names, fact_name_hashes, fact_names_hash_seed);

        writeln(fmtr, "static uint32_t s_fact_name_hashes[] = {");
        for (uint32_t fact_idx = 0; fact_idx < size(world->facts); ++fact_idx)
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "%u, ", fact_name_hashes[fact_idx]);
        }

        if (empty(world->facts))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    uint32_t task_names_hash_seed = 0;
    // s_task_name_hashes
    {
        Memory_Stack_Scope scratch_scope(self->scratch);

        const uint32_t num_tasks = size(prim->tasks) + size(domain->tasks);
        Array<Token_Value> task_names;
        init(task_names, self->scratch, num_tasks);
        Array<uint32_t> task_name_hashes;
        init(task_name_hashes, self->scratch, num_tasks);

        // primtives go first
        for (uint32_t prim_idx = 0; prim_idx < size(prim->tasks); ++prim_idx)
        {
            push_back(task_names, prim->tasks[prim_idx]->name);
        }
        // compound next
        for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
        {
            push_back(task_names, domain->tasks[task_idx]->name);
        }

        build_hashes(task_names, task_name_hashes, task_names_hash_seed);

        writeln(fmtr, "static uint32_t s_task_name_hashes[] = {");
        for (uint32_t hash_idx = 0; hash_idx < size(task_name_hashes); ++hash_idx)
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "%u, ", task_name_hashes[hash_idx]);
        }

        if (empty(task_name_hashes))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    uint32_t symbol_values_hash_seed = 0;
    // s_symbol_values & s_symbol_hashes
    {
        Memory_Stack_Scope scratch_scope(self->scratch);

        Array<Token_Value> symbol_values;
        init(symbol_values, self->scratch, size(self->tree->symbols));
        Array<uint32_t> symbol_hashes;
        init(symbol_hashes, self->scratch, size(self->tree->symbols));

        values(self->tree->symbols, symbol_values);

        build_hashes(symbol_values, symbol_hashes, symbol_values_hash_seed);

        writeln(fmtr, "static const char* s_symbol_values[] = {");
        for (uint32_t symbol_idx = 0; symbol_idx < size(symbol_values); ++symbol_idx)
        {
            Indent_Scope s(fmtr);
            Token_Value value = symbol_values[symbol_idx];
            writeln(fmtr, "\"%n\",", value);
        }

        if (empty(symbol_values))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, " };");
        newline(fmtr);

        writeln(fmtr, "static uint32_t s_symbol_hashes[] = {");
        for (uint32_t hash_idx = 0; hash_idx < size(symbol_hashes); ++hash_idx)
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "%u, ", symbol_hashes[hash_idx]);
        }

        if (empty(symbol_hashes))
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "0");
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // s_domain_info
    {
        const uint32_t num_tasks = size(prim->tasks) + size(domain->tasks);
        const uint32_t num_primitive = size(prim->tasks);
        const uint32_t num_compound = size(domain->tasks);
        writeln(fmtr, "static Domain_Info s_domain_info = {");
        {
            Indent_Scope s(fmtr);
            // task_info
            writeln(fmtr, "{ %d, %d, %d, s_num_cases, s_first_case, %d, s_task_name_hashes, s_task_names, s_task_parameters, s_bindings, s_num_case_handles, s_task_expands },",
                num_tasks, num_primitive, num_compound, task_names_hash_seed);
            // database_req
            writeln(fmtr, "{ %d, %d, s_size_hints, s_fact_types, s_fact_name_hashes, s_fact_names },", size(world->facts), fact_names_hash_seed);
            // symbols
            writeln(fmtr, "{ %d, %d, s_symbol_hashes, s_symbol_values }", size(self->tree->symbols), symbol_values_hash_seed);
        }
        writeln(fmtr, "};");
        newline(fmtr);
    }

    // init_domain_info & get_domain_info
    {
        writeln(fmtr, "void %n_init_domain_info()", domain->name);
        writeln(fmtr, "{");
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "for (size_t i = 0; i < plnnr_static_array_size(s_task_parameters); ++i) {");
            {
                Indent_Scope s(fmtr);
                writeln(fmtr, "compute_offsets_and_size(&s_task_parameters[i]);");
            }
            writeln(fmtr, "}");
            newline(fmtr);

            writeln(fmtr, "for (size_t i = 0; i < plnnr_static_array_size(s_bindings); ++i) {");
            {
                Indent_Scope s(fmtr);
                writeln(fmtr, "compute_offsets_and_size(&s_bindings[i]);");
            }
            writeln(fmtr, "}");
        }
        writeln(fmtr, "}");
        newline(fmtr);

        writeln(fmtr, "const Domain_Info* %n_get_domain_info() { return &s_domain_info; }", domain->name);
        newline(fmtr);
    }

    // accessor structs
    {
        for (uint32_t sig_idx = 0; sig_idx < size_dense(self->struct_sigs); ++sig_idx)
        {
            Signature sig = get_dense(self->struct_sigs, sig_idx);
            if (sig.length == 0) { continue; }

            writeln(fmtr, "struct S_%d {", sig_idx);
            for (uint32_t param_idx = 0; param_idx < sig.length; ++param_idx)
            {
                Indent_Scope s(fmtr);
                Token_Type param_type = sig.types[param_idx];
                const char* type_name = get_runtime_type_name(param_type);
                writeln(fmtr, "%s _%d;", type_name, param_idx);
            }
            writeln(fmtr, "};");
            newline(fmtr);
        }
    }

    // precondition iterators
    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        generate_precondition(self, case_idx, fmtr);
    }

    // case expansions
    for (uint32_t case_idx = 0; case_idx < size(tree->cases); ++case_idx)
    {
        ast::Case* case_ = tree->cases[case_idx];
        generate_expansion(self, case_, case_idx, fmtr);
    }

    // generate empty expansions for the tasks without cases
    for (uint32_t task_idx = 0; task_idx < size(domain->tasks); ++task_idx)
    {
        ast::Task* task = domain->tasks[task_idx];
        if (empty(task->cases))
        {
            generate_empty_expansion(self, task, fmtr);
        }
    }

    flush(fmtr);
}

static void generate_precondition(Codegen* self, uint32_t case_idx, Formatter& fmtr)
{
    ast::Domain* domain = self->tree->domain;
    ast::Case* case_ = self->tree->cases[case_idx];

    uint32_t task_idx = index_of(domain->tasks, case_->task);

    uint32_t output_idx = get_dense_index(self->struct_sigs, size(domain->tasks) + case_idx);
    uint32_t struct_idx = get_dense_index(self->struct_sigs, task_idx);
    Signature output_sig = get_dense(self->struct_sigs, output_idx);
    Signature struct_sig = get_dense(self->struct_sigs, struct_idx);

    const bool has_args = (struct_sig.length > 0);
    const bool has_output = (output_sig.length > 0);

    ast::Attribute* attr_sorted = find_attribute(case_, Attribute_Sorted);
    if (attr_sorted)
    {
        generate_comparator(self, attr_sorted->args[0], attr_sorted->types[0], has_args, case_idx, struct_idx, output_idx, fmtr);
    }

    writeln(fmtr, "static bool p%d_next(Planning_State* state, Expansion_Frame* frame, Fact_Database* db)", case_idx);

    ast::Expr* precond = case_->precond;
    plnnrc_assert(is_Or(precond));

    // trivial precondition expression.
    if (!precond->child)
    {
        writeln(fmtr, "{");
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "plnnr_coroutine_begin(frame, precond_label);");
            writeln(fmtr, "plnnr_coroutine_yield(frame, precond_label, 1);");
            writeln(fmtr, "plnnr_coroutine_end();");
        }
        writeln(fmtr, "}");
        newline(fmtr);
        return;
    }

    writeln(fmtr, "{");
    {
        Indent_Scope s(fmtr);
        writeln(fmtr, "Fact_Handle* handles = frame->handles;");

        if (has_args)
            writeln(fmtr, "const S_%d* args = (const S_%d*)(frame->arguments);", struct_idx, struct_idx);

        if (has_output)
            writeln(fmtr, "S_%d* binds = (S_%d*)(frame->bindings);", output_idx, output_idx);

        newline(fmtr);
        writeln(fmtr, "plnnr_coroutine_begin(frame, precond_label);");
        newline(fmtr);

        uint32_t handle_id = 0;
        uint32_t yield_id = 1;
        bool is_empty_precond = true;
        for (ast::Expr* conjunct = precond->child; conjunct != 0; conjunct = conjunct->next_sibling)
        {
            ast::Expr* node = conjunct;
            if (is_And(conjunct))
            {
                // empty `and`.
                if (!conjunct->child)
                {
                    is_empty_precond &= true;
                    continue;
                }

                is_empty_precond = false;
                node = conjunct->child;
            }

            if (attr_sorted)
            {
                if (conjunct != precond->child)
                    writeln(fmtr, "revert(&state->expansion_blob, binds + 1);");

                writeln(fmtr, "frame->num_bindings = 0;");
            }

            generate_conjunct(self, case_, node, handle_id, yield_id, attr_sorted != 0, case_idx, output_idx, fmtr);

            if (attr_sorted)
            {
                newline(fmtr);

                writeln(fmtr, "if (frame->num_bindings > 0) {");
                {
                    Indent_Scope s(fmtr);
                    writeln(fmtr, "revert(&state->expansion_blob, binds);");
                }
                writeln(fmtr, "}");
                newline(fmtr);

                if (has_args)
                    writeln(fmtr, "std::sort(binds - frame->num_bindings, binds, Compare_p%d(args));", case_idx);
                else
                    writeln(fmtr, "std::sort(binds - frame->num_bindings, binds, Compare_p%d());", case_idx);

                newline(fmtr);
                writeln(fmtr, "for (frame->binding_index = 0; frame->binding_index < frame->num_bindings; ++frame->binding_index) {");
                {
                    Indent_Scope s(fmtr);
                    writeln(fmtr, "plnnr_coroutine_yield(frame, precond_label, %d);", yield_id++);
                }
                writeln(fmtr, "}");
                newline(fmtr);
            }
        }

        // empty precondition expression.
        if (is_empty_precond)
        {
            writeln(fmtr, "plnnr_coroutine_yield(frame, precond_label, %d);", yield_id++);
        }

        newline(fmtr);
        writeln(fmtr, "plnnr_coroutine_end();");
    }

    writeln(fmtr, "}");
    newline(fmtr);
}

static void generate_conjunct(Codegen* self, ast::Case* case_, ast::Expr* literal, uint32_t& handle_id, uint32_t& yield_id, bool store_binds, uint32_t case_index, uint32_t output_index, Formatter& fmtr)
{
    ast::Func* func = is_Not(literal) ? as_Func(literal->child) : as_Func(literal);

    ast::Fact* fact = 0;
    if (func)
        fact = get_fact(self->tree, func->name);

    // expression -> generate `if` check.
    if (!func || !fact)
    {
        Expr_Writer visitor = { &fmtr, self->tree };
        ast::Expr* expr = is_Not(literal) ? literal->child : literal;

        if (is_Assign(expr))
        {
            write(fmtr, "%i");
            visit_node<void>(expr, &visitor);
            write(fmtr, "; {");
            newline(fmtr);
        }
        else
        {
            if (is_Not(literal))
                write(fmtr, "%iif (!bool(");
            else
                write(fmtr, "%iif (bool(");

            visit_node<void>(expr, &visitor);

            write(fmtr, ")) {");
            newline(fmtr);
        }

        Indent_Scope indent_scope(fmtr);

        if (!literal->next_sibling)
        {
            if (!store_binds)
            {
                writeln(fmtr, "plnnr_coroutine_yield(frame, precond_label, %d);", yield_id++);
            }
            else
            {
                writeln(fmtr, "binds = (S_%d*)(allocate_precond_bindings(state, &s_bindings[%d]));", output_index, case_index);
                writeln(fmtr, "++frame->num_bindings;");
            }
        }
        else
        {
            generate_conjunct(self, case_, literal->next_sibling, handle_id, yield_id, store_binds, case_index, output_index, fmtr);
        }
    }
    // fact -> generate iterator.
    else
    {
        ast::Fact* fact = get_fact(self->tree, func->name);
        uint32_t fact_idx = index_of(self->tree->world->facts, fact);

        writeln(fmtr, "for (handles[%d] = first(db, tbl(state, %d)); is_valid(db, handles[%d]); handles[%d] = next(db, handles[%d])) { // %n",
            handle_id, fact_idx, handle_id, handle_id, handle_id, fact->name);
        {
            Indent_Scope indent_scope(fmtr);

            const char* comparison_op = is_Not(literal) ? "==" : "!=";
            for (uint32_t arg_idx = 0; arg_idx < size(func->args); ++arg_idx)
            {
                ast::Expr* arg = func->args[arg_idx];

                Token_Type source_data_type = fact->params[arg_idx]->data_type;
                const char* source_data_type_tag = get_runtime_type_tag(source_data_type);
                const char* source_data_type_name = get_runtime_type_name(source_data_type);

                // variable -> match or create a new binding.
                if (ast::Var* var = as_Var(arg))
                {
                    Token_Type target_data_type = var->data_type;
                    const char* target_data_type_name = get_runtime_type_name(target_data_type);

                    // yet unbound variable -> create binding.
                    if (var->binding)
                    {
                        writeln(fmtr, "binds->_%d = %s(as_%s(db, handles[%d], %d));",
                            var->output_index, target_data_type_name, source_data_type_tag, handle_id, arg_idx);
                        continue;
                    }

                    ast::Node* def = var->definition;

                    // parameter -> match with the variable in `args` struct.
                    if (ast::Param* param = as_Param(def))
                    {
                        ast::Var* first = get(case_->precond_var_lookup, param->name);
                        writeln(fmtr, "if (args->_%d %s %s(as_%s(db, handles[%d], %d))) {",
                            first->input_index, comparison_op, target_data_type_name, source_data_type_tag, handle_id, arg_idx);
                        {
                            Indent_Scope s(fmtr);
                            writeln(fmtr, "continue;");
                        }
                        writeln(fmtr, "}");
                        newline(fmtr);
                        continue;
                    }

                    // variable -> matching with existing binding.
                    if (ast::Var* var_def = as_Var(def))
                    {
                        writeln(fmtr, "if (binds->_%d %s %s(as_%s(db, handles[%d], %d))) {",
                            var_def->output_index, comparison_op, target_data_type_name, source_data_type_tag, handle_id, arg_idx);
                        {
                            Indent_Scope s(fmtr);
                            writeln(fmtr, "continue;");
                        }
                        writeln(fmtr, "}");
                        newline(fmtr);
                        continue;
                    }

                    plnnrc_assert(false);
                }

                // expression -> match result with handle.
                {
                    Expr_Writer visitor = { &fmtr, self->tree };

                    write(fmtr, "%iif (%s(", source_data_type_name);
                    visit_node<void>(arg, &visitor);
                    write(fmtr, ") %s as_%s(db, handles[%d], %d)) {", comparison_op, source_data_type_tag, handle_id, arg_idx);
                    newline(fmtr);
                    {
                        Indent_Scope s(fmtr);
                        writeln(fmtr, "continue;");
                    }
                    writeln(fmtr, "}");
                    newline(fmtr);
                }
            }

            ++handle_id;

            if (!literal->next_sibling)
            {
                if (!store_binds)
                {
                    writeln(fmtr, "plnnr_coroutine_yield(frame, precond_label, %d);", yield_id++);
                }
                else
                {
                    writeln(fmtr, "binds = (S_%d*)(allocate_precond_bindings(state, &s_bindings[%d]));", output_index, case_index);
                    writeln(fmtr, "++frame->num_bindings;");
                }
            }
            else
            {
                generate_conjunct(self, case_, literal->next_sibling, handle_id, yield_id, store_binds, case_index, output_index, fmtr);
            }
        }
    }

    writeln(fmtr, "}");
}

static void generate_comparator(Codegen* self, ast::Expr* key_expr, Token_Type key_type, bool has_args, uint32_t case_index, uint32_t struct_index, uint32_t output_index, Formatter& fmtr)
{
    const char* key_data_type_name = get_runtime_type_name(key_type);

    writeln(fmtr, "struct Compare_p%d {", case_index);
    {
        Indent_Scope s(fmtr);

        if (has_args)
        {
            writeln(fmtr, "const S_%d* args;", struct_index);
            writeln(fmtr, "Compare_p%d(const S_%d* args) :args(args) {}", case_index, struct_index);
            newline(fmtr);
        }

        writeln(fmtr, "inline %s key(const S_%d* binds) const {", key_data_type_name, output_index);
        {
            Indent_Scope s(fmtr);
            Expr_Writer visitor = { &fmtr, self->tree };
            write(fmtr, "%ireturn %s(", key_data_type_name);
            visit_node<void>(key_expr, &visitor);
            write(fmtr, ");");
            newline(fmtr);
        }
        writeln(fmtr, "}");
        newline(fmtr);

        writeln(fmtr, "inline bool operator()(const S_%d& a, const S_%d& b) const {", output_index, output_index);
        {
            Indent_Scope s(fmtr);
            writeln(fmtr, "return key(&a) < key(&b);");
        }
        writeln(fmtr, "}");
    }
    writeln(fmtr, "};");
    newline(fmtr);
}

template <typename Param_Node>
static void generate_arg_setters(Codegen* self, const char* set_arg_name, ast::Func* task_func, uint32_t target_task_index, const Array<Param_Node*>& param_types, Formatter& fmtr)
{
    for (uint32_t arg_idx = 0; arg_idx < size(task_func->args); ++arg_idx)
    {
        ast::Expr* arg = task_func->args[arg_idx];
        Token_Type target_data_type = param_types[arg_idx]->data_type;
        const char* target_data_type_name = get_runtime_type_name(target_data_type);

        if (ast::Var* arg_var = as_Var(arg))
        {
            if (ast::Var* def_var = as_Var(arg_var->definition))
            {
                writeln(fmtr, "%s(state, &s_task_parameters[%d], %d, %s(binds->_%d));",
                    set_arg_name, target_task_index, arg_idx, target_data_type_name, def_var->output_index);
                continue;
            }

            if (is_Param(arg_var->definition))
            {
                writeln(fmtr, "%s(state, &s_task_parameters[%d], %d, %s(args->_%d));",
                    set_arg_name, target_task_index, arg_idx, target_data_type_name, arg_var->input_index);
                continue;
            }

            // undefined variable must have been reported as an error earlier.
            plnnrc_assert(false);
        }

        // expression
        {
            Expr_Writer visitor = { &fmtr, self->tree };

            write(fmtr, "%i%s(state, &s_task_parameters[%d], %d, %s(",
                set_arg_name, target_task_index, arg_idx, target_data_type_name);

            visit_node<void>(arg, &visitor);

            write(fmtr, "));");
            newline(fmtr);
        }
    }
}

static void generate_expansion(Codegen* self, ast::Case* case_, uint32_t case_idx, Formatter& fmtr)
{
    ast::Domain* domain = self->tree->domain;
    ast::Task* task = case_->task;
    uint32_t task_idx = index_of(domain->tasks, task);
    Token_Value name = get(self->expand_names, case_idx);
    uint32_t yield_id = 1;

    writeln(fmtr, "static bool %n(Planning_State* state, Expansion_Frame* frame, Fact_Database* db)", name);
    writeln(fmtr, "{");
    {
        Indent_Scope s(fmtr);

        uint32_t struct_idx = get_dense_index(self->struct_sigs, task_idx);
        if (get_dense(self->struct_sigs, struct_idx).length > 0)
            writeln(fmtr, "const S_%d* args = (const S_%d*)(frame->arguments);",
                struct_idx, struct_idx);

        uint32_t binding_idx = get_dense_index(self->struct_sigs, size(domain->tasks) + case_idx);
        const bool has_binds = get_dense(self->struct_sigs, binding_idx).length > 0;
        if (has_binds)
            writeln(fmtr, "const S_%d* binds = (const S_%d*)(frame->bindings);",
                binding_idx, binding_idx);

        newline(fmtr);

        writeln(fmtr, "plnnr_coroutine_begin(frame, expand_label);");
        newline(fmtr);

        writeln(fmtr, "while (p%d_next(state, frame, db)) {", case_idx);

        // generate task list expansion
        {
            Indent_Scope s(fmtr);

            if (empty(case_->task_list))
            {
                writeln(fmtr, "frame->status = Expansion_Frame::Status_Expanded;");
                writeln(fmtr, "plnnr_coroutine_yield(frame, expand_label, %d);", yield_id++);
            }
            else if (has_binds)
            {
                writeln(fmtr, "binds = binds + frame->binding_index;");
            }

            for (uint32_t item_idx = 0; item_idx < size(case_->task_list); ++item_idx)
            {
                ast::Func* item = as_Func(case_->task_list[item_idx]);
                // adding primitive task to expansion.
                if (ast::Fact* primitive = get_primitive(self->tree, item->name))
                {
                    uint32_t primitive_index = index_of(self->tree->primitive->tasks, primitive);
                    writeln(fmtr, "begin_task(state, &s_domain_info, %d); // %n",
                        primitive_index, primitive->name);

                    generate_arg_setters(self, "set_task_arg", item, primitive_index, primitive->params, fmtr);

                    if (item == back(case_->task_list) && !case_->foreach)
                    {
                        writeln(fmtr, "frame->status = Expansion_Frame::Status_Expanded;");
                    }

                    writeln(fmtr, "plnnr_coroutine_yield(frame, expand_label, %d);", yield_id++);
                    newline(fmtr);

                    if (item == back(case_->task_list) && case_->foreach)
                    {
                        writeln(fmtr, "continue_iteration(state, frame);");
                    }

                    continue;
                }

                // adding compound task to expansion.
                if (ast::Task* compound = get_task(self->tree, item->name))
                {
                    uint32_t compound_index = size(self->tree->primitive->tasks) + index_of(self->tree->domain->tasks, compound);
                    writeln(fmtr, "begin_compound(state, &s_domain_info, %d); // %n",
                        compound_index, compound->name);

                    generate_arg_setters(self, "set_compound_arg", item, compound_index, compound->params, fmtr);

                    if (item == back(case_->task_list) && !case_->foreach)
                    {
                        writeln(fmtr, "frame->status = Expansion_Frame::Status_Expanded;");
                    }

                    writeln(fmtr, "plnnr_coroutine_yield(frame, expand_label, %d);", yield_id++);
                    newline(fmtr);

                    if (item == back(case_->task_list) && case_->foreach)
                    {
                        writeln(fmtr, "continue_iteration(state, frame);");
                    }

                    continue;
                }

                plnnrc_assert(false);
            }
        }

        writeln(fmtr, "}");
        newline(fmtr);

        if (case_->foreach)
        {
            writeln(fmtr, "if (frame->status == Expansion_Frame::Status_Was_Expanded) {");
            {
                Indent_Scope s(fmtr);
                writeln(fmtr, "frame->status = Expansion_Frame::Status_Expanded;");
                writeln(fmtr, "plnnr_coroutine_yield(frame, expand_label, %d);", yield_id++);
            }
            writeln(fmtr, "}");
            newline(fmtr);
        }

        if (case_ != back(task->cases))
        {
            uint32_t task_id = index_of(self->tree->domain->tasks, task) + size(self->tree->primitive->tasks);
            Token_Value next_expand_name = get(self->expand_names, case_idx + 1);
            writeln(fmtr, "return expand_next_case(state, &s_domain_info, %d, frame, db, %n);",
                task_id, next_expand_name);
            newline(fmtr);
        }

        writeln(fmtr, "plnnr_coroutine_end();");
    }

    writeln(fmtr, "}");
    newline(fmtr);
}

static void generate_empty_expansion(Codegen* /*self*/, ast::Task* task, Formatter& fmtr)
{
    writeln(fmtr, "static bool %n_case_0(Planning_State* state, Expansion_Frame* frame, Fact_Database* db)", task->name);
    writeln(fmtr, "{");
    {
        Indent_Scope s(fmtr);
        writeln(fmtr, "plnnr_coroutine_begin(frame, expand_label);");
        writeln(fmtr, "plnnr_coroutine_end();");
    }
    writeln(fmtr, "}");
    newline(fmtr);
}
