//
// Copyright (c) 2015 Alexander Shafranov shafranov@gmail.com
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//

#include "derplanner/compiler/io.h"
#include "derplanner/compiler/array.h"
#include "derplanner/compiler/codegen.h"
#include "derplanner/compiler/string_buffer.h"
#include "pool.h"

using namespace plnnrc;

void plnnrc::init(Codegen& state, ast::Root* tree)
{
    state.tree = tree;
    state.pool = create_paged_pool(32*1024);
    init(state.expand_names, state.pool, 64, 4096);
}

void plnnrc::destroy(Codegen& state)
{
    destroy(state.expand_names);
    destroy(state.pool);
}

plnnrc::Codegen::Codegen() : pool(0) {}

plnnrc::Codegen::~Codegen() { destroy(*this); }


void plnnrc::generate_header(Codegen& state, const char* header_guard, Writer* output)
{
    init(state.fmtr, "  ", "\n", output);
    ast::Root* tree = state.tree;
    ast::Domain* domain = tree->domain;
    Formatter& fmtr = state.fmtr;

    Token_Value domain_name = domain->name;
    writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
    writeln(fmtr, "#ifndef %s", header_guard);
    writeln(fmtr, "#define %s", header_guard);
    writeln(fmtr, "#pragma once");
    newline(fmtr);
    writeln(fmtr, "#include \"derplanner/runtime/types.h\"");
    newline(fmtr);
    writeln(fmtr, "#ifndef PLNNR_DOMAIN_API");
    writeln(fmtr, "#define PLNNR_DOMAIN_API");
    writeln(fmtr, "#endif");
    newline(fmtr);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API void %n_init_domain_info();", domain_name);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API const plnnr::Domain_Info* %n_get_domain_info();", domain_name);
    newline(fmtr);
    writeln(fmtr, "#endif");
    flush(fmtr);
}

static void build_expand_names(String_Buffer& expand_names, ast::Domain* domain)
{
    for (uint32_t taskIdx = 0; taskIdx < plnnrc::size(domain->tasks); ++taskIdx)
    {
        ast::Task* task = domain->tasks[taskIdx];
        for (uint32_t caseIdx = 0; caseIdx < plnnrc::size(task->cases); ++caseIdx)
        {
            begin_string(expand_names);
            write(expand_names.buffer, "%n_case_%d", task->name, caseIdx);
            end_string(expand_names);
        }
    }
}

static const char* s_type_names[] =
{
    #define PLNNRC_TYPE_KEYWORD_TOKEN(TAG, STR) "Type_" #TAG,
    #include "derplanner/compiler/token_tags.inl"
    #undef PLNNRC_TYPE_KEYWORD_TOKEN
};

static inline const char* get_runtime_type_name(Token_Type token_type)
{
    plnnrc_assert(token_type >= Token_Int32);
    return s_type_names[token_type - Token_Int32];
}

void plnnrc::generate_source(Codegen& state, const char* domain_header, Writer* output)
{
    init(state.fmtr, "  ", "\n", output);
    ast::Root* tree = state.tree;
    ast::World* world = tree->world;
    ast::Primitive* prim = tree->primitive;
    ast::Domain* domain = tree->domain;
    Formatter& fmtr = state.fmtr;
    String_Buffer& expand_names = state.expand_names;

    writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
    writeln(fmtr, "#include \"derplanner/runtime/domain_support.h\"");
    writeln(fmtr, "#include \"%s\"", domain_header);
    newline(fmtr);
    writeln(fmtr, "using namespace plnnr;");
    newline(fmtr);
    writeln(fmtr, "#ifdef __GNUC__");
    writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-parameter\"");
    writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-variable\"");
    writeln(fmtr, "#endif");
    newline(fmtr);
    writeln(fmtr, "#ifdef _MSC_VER");
    writeln(fmtr, "#pragma warning(disable: 4100) // unreferenced formal parameter");
    writeln(fmtr, "#pragma warning(disable: 4189) // local variable is initialized but not referenced");
    writeln(fmtr, "#endif");
    newline(fmtr);

    build_expand_names(expand_names, domain);

    for (uint32_t caseIdx = 0; caseIdx < size(expand_names); ++caseIdx)
    {
        Token_Value name = get(expand_names, caseIdx);
        writeln(fmtr, "static bool %n(Planning_State*, Expansion_Frame*, Fact_Database*);", name);
    }
    newline(fmtr);

    writeln(fmtr, "static Composite_Task_Expand* s_task_expands[] = {");
    for (uint32_t caseIdx = 0; caseIdx < size(expand_names); ++caseIdx)
    {
        Token_Value name = get(expand_names, caseIdx);
        Indent_Scope s(fmtr);
        writeln(fmtr, "%n,", name);
    }
    writeln(fmtr, "};");
    newline(fmtr);

    writeln(fmtr, "static const char* s_fact_names[] = {");
    for (uint32_t factIdx = 0; factIdx < size(world->facts); ++factIdx)
    {
        Indent_Scope s(fmtr);
        ast::Fact* fact = world->facts[factIdx];
        writeln(fmtr, "\"%n\"", fact->name);
    }
    writeln(fmtr, " };");
    newline(fmtr);

    writeln(fmtr, "static const char* s_task_names[] = {");
    // primitive tasks go first.
    for (uint32_t primIdx = 0; primIdx < size(prim->tasks); ++primIdx)
    {
        Indent_Scope s(fmtr);
        ast::Fact* task = prim->tasks[primIdx];
        writeln(fmtr, "\"%n\"", task->name);
    }
    // composite tasks after.
    for (uint32_t taskIdx = 0; taskIdx < size(domain->tasks); ++taskIdx)
    {
        Indent_Scope s(fmtr);
        ast::Task* task = domain->tasks[taskIdx];
        writeln(fmtr, "\"%n\"", task->name);
    }
    writeln(fmtr, " };");
    newline(fmtr);

    writeln(fmtr, "static Fact_Type s_fact_types[] = {");
    for (uint32_t factIdx = 0; factIdx < size(world->facts); ++factIdx)
    {
        ast::Fact* fact = world->facts[factIdx];
        uint32_t num_params = size(fact->params);
        Indent_Scope s(fmtr);
        write(fmtr, "%i{ %d, {", num_params);
        for (uint32_t paramIdx = 0; paramIdx < num_params; ++paramIdx)
        {
            const char* type_name = get_runtime_type_name(fact->params[paramIdx]->data_type);
            write(fmtr, "%s, ", type_name);
        }
        write(fmtr, "} }");
        newline(fmtr);
    }
    writeln(fmtr, "};");
    newline(fmtr);

    flush(fmtr);
}
