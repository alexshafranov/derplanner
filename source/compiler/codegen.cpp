//
// Copyright (c) 2015 Alexander Shafranov shafranov@gmail.com
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//

#include "derplanner/compiler/io.h"
#include "derplanner/compiler/array.h"
#include "derplanner/compiler/codegen.h"
#include "derplanner/compiler/string_buffer.h"
#include "pool.h"

using namespace plnnrc;

void plnnrc::init(Codegen& state, ast::Root* tree)
{
    state.tree = tree;
    state.pool = create_paged_pool(32*1024);
}

void plnnrc::destroy(Codegen& state)
{
    destroy(state.pool);
}

plnnrc::Codegen::Codegen() : pool(0) {}

plnnrc::Codegen::~Codegen() { destroy(*this); }


void plnnrc::generate_header(Codegen& state, const char* header_guard, Writer* output)
{
    init(state.fmtr, "  ", "\n", output);
    ast::Root* tree = state.tree;
    ast::Domain* domain = tree->domain;
    Formatter& fmtr = state.fmtr;

    Token_Value domain_name = domain->name;
    writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
    writeln(fmtr, "#ifndef %s", header_guard);
    writeln(fmtr, "#define %s", header_guard);
    writeln(fmtr, "#pragma once");
    newline(fmtr);
    writeln(fmtr, "#include \"derplanner/runtime/types.h\"");
    newline(fmtr);
    writeln(fmtr, "#ifndef PLNNR_DOMAIN_API");
    writeln(fmtr, "#define PLNNR_DOMAIN_API");
    writeln(fmtr, "#endif");
    newline(fmtr);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API void %n_init_domain_info();", domain_name);
    writeln(fmtr, "extern \"C\" PLNNR_DOMAIN_API const plnnr::Domain_Info* %n_get_domain_info();", domain_name);
    newline(fmtr);
    writeln(fmtr, "#endif");
    flush(fmtr);
}

void plnnrc::generate_source(Codegen& state, const char* domain_header, Writer* output)
{
    init(state.fmtr, "  ", "\n", output);
    ast::Root* tree = state.tree;
    ast::World* world = tree->world;
    ast::Domain* domain = tree->domain;
    Formatter& fmtr = state.fmtr;

    writeln(fmtr, "// generated by derplanner [http://www.github.com/alexshafranov/derplanner]");
    writeln(fmtr, "#include \"derplanner/runtime/domain_support.h\"");
    writeln(fmtr, "#include \"%s\"", domain_header);
    newline(fmtr);
    writeln(fmtr, "using namespace plnnr;");
    newline(fmtr);
    writeln(fmtr, "#ifdef __GNUC__");
    writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-parameter\"");
    writeln(fmtr, "#pragma GCC diagnostic ignored \"-Wunused-variable\"");
    writeln(fmtr, "#endif");
    newline(fmtr);
    writeln(fmtr, "#ifdef _MSC_VER");
    writeln(fmtr, "#pragma warning(disable: 4100) // unreferenced formal parameter");
    writeln(fmtr, "#pragma warning(disable: 4189) // local variable is initialized but not referenced");
    writeln(fmtr, "#endif");
    newline(fmtr);

    String_Buffer expand_names;
    init(expand_names, state.pool, 32, 4096);

    for (uint32_t taskIdx = 0; taskIdx < plnnrc::size(domain->tasks); ++taskIdx)
    {
        ast::Task* task = domain->tasks[taskIdx];
        for (uint32_t caseIdx = 0; caseIdx < plnnrc::size(task->cases); ++caseIdx)
        {
            writeln(fmtr, "static bool %n_case_%d(Planning_State*, Expansion_Frame*, Fact_Database*);", task->name, caseIdx);
        }
    }

    // static Composite_Task_Expand* s_task_expands[] = { root_case_0, travel_case_0, travel_by_plane_case_0 };

    // newline(fmtr);
    // writeln(fmtr, "static Composite_Task_Expand* s_task_expands[] = { ");
    // for (uint32_t taskIdx = 0; taskIdx < plnnrc::size(domain->tasks); ++taskIdx)
    // {
    //     for (uint32_t caseIdx = 0; caseIdx < plnnrc::size(ta))
    // }
    // writeln(fmtr, " };");

    newline(fmtr);
    writeln(fmtr, "static const char* s_fact_names[] = { ");
    for (uint32_t factIdx = 0; factIdx < plnnrc::size(world->facts); ++factIdx)
    {
        Indent_Scope s(fmtr);
        ast::Fact* fact = world->facts[factIdx];
        writeln(fmtr, "\"%n\"", fact->name);
    }
    writeln(fmtr, " };");

    // static const char* s_fact_names[] = { "start", "finish", "short_distance", "long_distance", "airport" };
    // static const char* s_task_names[] = { "!taxi", "!plane", "root", "travel", "travel_by_plane" };

    newline(fmtr);
    flush(fmtr);
}
